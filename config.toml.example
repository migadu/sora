# SORA MAIL SERVER - CONFIGURATION FILE
# =============================================================================
#
# This is the main configuration file for Sora, a hackable IMAP server built
# with Go and PostgreSQL. This file contains all available configuration
# options with detailed explanations and examples.
#
# IMPORTANT:
# - Copy this file to config.toml and modify the values for your deployment
# - All sections and options are documented with their default values
# - Duration values accept Go duration format: "1h", "30m", "5s", "100ms"
# - Size values accept common suffixes: "1gb", "100mb", "5kb"
#
# CONFIG VALIDATION:
# - Unknown keys will log warnings but are ignored (helps detect typos)
# - Duplicate keys will log warnings and use first occurrence
# - Syntax errors (e.g., "f" instead of "false") will fail with helpful hints
# - Run './sora --config config.toml' to validate your configuration

# ADMIN CLI CONFIGURATION (for sora-admin tool)
# =============================================================================
# Configuration for the sora-admin CLI tool to connect to the HTTP Admin API server.
# Required for commands like 'sora-admin connections list', 'connections kick', etc.

[admin_cli]
# addr = "http://localhost:8080"              # HTTP Admin API endpoint address (use https:// if TLS is enabled)
# api_key = "your-api-key-here"               # API key matching the http_admin_api server configuration
# insecure_skip_verify = true                 # Skip TLS certificate verification (default: true). Set to false for production with valid certs.


# LOGGING CONFIGURATION
# =============================================================================
# Structured logging configuration using Go's standard slog library.

[logging]
output = "stderr"         # Log destination: "stderr", "stdout", "syslog", or "/path/to/file.log"
format = "console"        # Log format: "json" for structured JSON logs, "console" for human-readable text
level = "info"            # Log level: "debug", "info", "warn", "error"


# DATABASE CONFIGURATION
# =============================================================================
# PostgreSQL database connection settings with read/write split support.
# Sora requires PostgreSQL with the pg_trgm extension for full-text search.

[database]
debug = false                   # Enable SQL query logging. Useful for debugging, but impacts performance.
query_timeout = "30s"           # Default timeout for all database queries (e.g., "30s", "1m").
search_timeout = "1m"           # Specific timeout for complex search queries (e.g., "60s", "2m").
write_timeout = "15s"           # Timeout for write operations (INSERT, UPDATE, DELETE).
migration_timeout = "2m"        # Timeout for auto-migrations at startup. When multiple instances start simultaneously,
                                # one will run migrations while others wait. If timeout is reached, the instance will
                                # verify migrations are complete before continuing. Default: "2m" (2 minutes).

# WRITE DATABASE CONFIGURATION
# =============================================================================
# Primary database endpoint for all write operations (INSERT, UPDATE, DELETE).

[database.write]
hosts = ["localhost"]         # Database server hosts. Can be ["host:port"] or multiple for failover.
port = 5432                   # Database port. Alternative to including it in hosts.
user = "postgres"             # Database username for authentication.
password = ""                 # Database user password. Leave empty for no password.
name = "sora_mail_db"         # Database name to connect to.
tls = false                   # Enable TLS/SSL for database connection. Recommended for remote connections.

# --- WRITE DATABASE CONNECTION POOL SETTINGS ---
# Fine-tune write database connection management for optimal performance.
max_conns = 50                  # Maximum connections in the write pool. Should be < PostgreSQL max_connections.
min_conns = 5                   # Minimum connections maintained in write pool (kept alive always).
max_conn_lifetime = "1h"        # Maximum lifetime before write connection refresh (prevents stale connections).
max_conn_idle_time = "30m"      # Maximum idle time before closing excess write connections (above min_conns).
query_timeout = "30s"           # Per-endpoint timeout for individual database queries (e.g., "30s").


# READ DATABASE CONFIGURATION
# =============================================================================
# Read replica database endpoint(s) for SELECT operations. Can specify multiple
# hosts for load balancing across read replicas. If not configured, read
# operations will use the write database connection pool.

[database.read]
hosts = ["localhost"]         # Database server hosts for read operations. Can specify multiple for load balancing.
port = 5432                   # Database port for read operations.
user = "postgres"             # Database username for read operations.
password = ""                 # Database user password for read operations.
name = "sora_mail_db"         # Database name for read operations (typically same as write).
tls = false                   # Enable TLS/SSL for read database connections.

# --- READ DATABASE CONNECTION POOL SETTINGS ---
# Fine-tune read database connection management for optimal performance.
max_conns = 100                 # Maximum connections in the read pool. Can be higher than write pool.
min_conns = 10                  # Minimum connections maintained in read pool.
max_conn_lifetime = "1h"        # Maximum lifetime before read connection refresh.
max_conn_idle_time = "30m"      # Maximum idle time before closing excess read connections.
query_timeout = "30s"           # Per-endpoint timeout for individual database queries (e.g., "30s").


# S3-COMPATIBLE OBJECT STORAGE CONFIGURATION  
# =============================================================================
# Sora stores message bodies in S3-compatible object storage for scalability
# and durability. Message metadata remains in PostgreSQL for fast access.

[s3]
endpoint = "s3.amazonaws.com"           # S3-compatible storage endpoint URL (e.g., "s3.amazonaws.com", "minio.example.com:9000").
disable_tls = false                     # Disable TLS for S3 endpoint. Useful for local MinIO setups.
access_key = "YOUR_S3_ACCESS_KEY_HERE"  # S3 access key ID for authentication.
secret_key = "YOUR_S3_SECRET_KEY_HERE"  # S3 secret access key for authentication.
bucket = "your-sora-mail-bucket"        # S3 bucket name for storing message bodies. Must be globally unique.
debug = false                           # Enable detailed S3 request/response tracing. Impacts performance.

# --- CLIENT-SIDE ENCRYPTION SETTINGS ---
# Encrypt message bodies before uploading to S3 for additional security
encrypt = false                                                                    # Enable client-side encryption. Messages are encrypted before S3 upload.
encryption_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef" # 32-byte master encryption key (64 hex chars). CRITICAL: Store securely! Gen: openssl rand -hex 32


# TLS/SSL CONFIGURATION
# =============================================================================
# TWO WAYS TO CONFIGURE TLS:
#
# OPTION A: Global TLS Manager (this section)
# - Centralized certificate management for ALL servers
# - Supports Let's Encrypt automatic certificates with auto-renewal
# - Supports file-based certificates
# - When enabled, ALL servers with tls=true will use certificates from here
# - Servers do NOT need tls_cert_file/tls_key_file when global TLS is enabled
#
# OPTION B: Per-Server TLS (in each [[server]] section)
# - Individual certificate files per server (tls_cert_file, tls_key_file)
# - More flexible but requires manual certificate management
# - Use this if you need different certificates per protocol/server
# - Global TLS manager must be DISABLED (enabled = false) to use per-server TLS
#
# IMPORTANT: You cannot mix both approaches!
# - If [tls] enabled = true → all servers use global TLS, ignore per-server tls_cert_file/tls_key_file
# - If [tls] enabled = false → each server needs its own tls_cert_file/tls_key_file
#
# RECOMMENDATION: Use global TLS with Let's Encrypt for automatic certificate management

[tls]
enabled = false                                 # Enable global TLS management (default: false)
provider = "file"                               # TLS provider: "file" or "letsencrypt" (default: "file")

# --- OPTION 1: FILE-BASED CERTIFICATES (provider = "file") ---
# Use this for static certificates (purchased SSL, self-signed, or existing certs)
# Both cert_file and key_file are REQUIRED when provider = "file"
cert_file = "/path/to/cert.pem"                 # Full path to PEM-encoded certificate file
key_file = "/path/to/key.pem"                   # Full path to PEM-encoded private key file

# EXAMPLE USAGE (Global TLS with file-based certificates):
# [tls]
# enabled = true
# provider = "file"
# cert_file = "/etc/ssl/certs/mail.example.com.crt"
# key_file = "/etc/ssl/private/mail.example.com.key"
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true                    # Enable TLS
# # tls_cert_file NOT needed - uses global [tls] cert
# # tls_key_file NOT needed - uses global [tls] cert

# --- OPTION 2: LET'S ENCRYPT AUTOMATIC CERTIFICATES (provider = "letsencrypt") ---
# Use this for automatic, free TLS certificates with auto-renewal
# REQUIREMENTS:
# - Domains must have DNS A records pointing to this server's public IP
# - Port 80 must be accessible from the internet (for HTTP-01 challenge validation)
# - S3 bucket for certificate storage (allows sharing across multiple instances)
# - AWS credentials or IAM role with S3 access
[tls.letsencrypt]
email = "admin@example.com"                     # REQUIRED: Email for Let's Encrypt account (used for expiration notices and account recovery)
domains = ["mail.example.com"]                  # REQUIRED: List of domains for certificate (supports multiple: ["mail.example.com", "imap.example.com", "smtp.example.com"])
default_domain = ""                             # OPTIONAL: Default domain to use when client doesn't provide SNI (Server Name Indication). If not specified, uses first domain from list.
                                                # Use this to handle legacy clients that don't support SNI.
storage_provider = "s3"                         # Certificate storage backend (currently only "s3" is supported)

# OPTIONAL: Customize certificate renewal window (default: 30 days before expiry)
# renew_before = "720h"                         # Renew certificates 720 hours (30 days) before expiration (format: "Xh", "Xd" not supported, use hours)

# OPTIONAL: Certificate synchronization from S3 (enabled by default)
# sync_interval = "5m"                          # Interval to check S3 for certificate updates (e.g., "5m", "10m", "1h"). Default: "5m"
#                                               # Set to "0" to disable periodic sync. When enabled, all cluster nodes will automatically
#                                               # download renewed certificates from S3 without restart. This ensures all nodes serve the
#                                               # same certificate even when the leader renews it.

# OPTIONAL: Local filesystem fallback for S3 outages (enabled by default)
# enable_fallback = true                        # Enable local filesystem fallback when S3 is unavailable (default: true)
# fallback_dir = "/var/lib/sora/certs"          # Local directory to cache certificates when S3 is unavailable (default: "/var/lib/sora/certs")
#
# IMPORTANT: If the fallback directory cannot be created (e.g., permission denied),
# Sora will automatically disable fallback and use S3-only mode with a warning.

# S3 storage configuration for Let's Encrypt certificates
# Certificates are stored in S3 to enable sharing across multiple Sora instances
[tls.letsencrypt.s3]
bucket = "sora-tls-certificates"                # S3 bucket name for certificate storage (bucket must exist before starting Sora)
endpoint = "s3.amazonaws.com"                   # S3-compatible storage endpoint (default: "s3.amazonaws.com" for AWS, or "minio.example.com:9000" for MinIO)
disable_tls = false                             # Disable TLS for S3 endpoint (useful for local MinIO setups)
debug = false                                   # Enable detailed S3 request/response tracing (impacts performance)
# access_key = ""                               # AWS/S3 access key (optional - uses IAM credentials chain if omitted)
# secret_key = ""                               # AWS/S3 secret key (optional - uses IAM credentials chain if omitted)
# This prevents server crashes due to filesystem permission issues.
#
# When to disable fallback (enable_fallback = false):
# - You prefer hard failure when S3 is down (fail-fast approach)
# - You don't want local disk dependencies
# - You're running in a container with ephemeral storage
# - You have strict compliance requirements about certificate storage locations

# EXAMPLE USAGE (Global TLS with Let's Encrypt):
# [tls]
# enabled = true
# provider = "letsencrypt"
# # cert_file and key_file are not needed for Let's Encrypt
#
# [tls.letsencrypt]
# email = "admin@example.com"
# domains = ["mail.example.com", "imap.example.com"]
# storage_provider = "s3"
#
# [tls.letsencrypt.s3]
# bucket = "sora-tls-certificates"
# region = "us-east-1"
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true                    # Enable TLS
# # tls_cert_file NOT needed - uses global [tls] cert
# # tls_key_file NOT needed - uses global [tls] cert

# --- OPTION 3: PER-SERVER TLS (Alternative to Global TLS) ---
# Use this if you need different certificates for different protocols/servers
# IMPORTANT: Global [tls] must be DISABLED (enabled = false) to use this approach
#
# EXAMPLE USAGE (Per-server TLS with different certificates):
# [tls]
# enabled = false               # MUST be false for per-server TLS
#
# [[server]]
# type = "imap"
# name = "main-imap"
# addr = ":993"
# tls = true
# tls_cert_file = "/etc/ssl/certs/imap.example.com.crt"
# tls_key_file = "/etc/ssl/private/imap.example.com.key"
#
# [[server]]
# type = "pop3"
# name = "main-pop3"
# addr = ":995"
# tls = true
# tls_cert_file = "/etc/ssl/certs/pop3.example.com.crt"  # Different cert!
# tls_key_file = "/etc/ssl/private/pop3.example.com.key"

# SETUP STEPS FOR LET'S ENCRYPT:
# 1. Create S3 bucket:
#    aws s3 mb s3://sora-tls-certificates --region us-east-1
# 2. Verify DNS A records:
#    dig +short mail.example.com  # Should return your server's public IP
# 3. Ensure port 80 is open:
#    Sora will automatically start an HTTP-01 challenge server on port 80
# 4. Set provider = "letsencrypt" and enabled = true
# 5. Start Sora - certificates will be issued on first HTTPS request
#
# FEATURES:
# - Automatic certificate issuance (30-60 seconds on first request)
# - Automatic renewal (certificates renewed 30 days before expiration by default, configurable via renew_before)
# - Hot reload (new certificates automatically loaded on next TLS handshake - no restart needed)
# - Multi-instance support (multiple Sora instances share certificates via S3)
# - Zero-downtime renewal (renewals happen in background during TLS handshakes)
# - Server-side encryption (certificates encrypted at rest with AES256)
# - File fallback (local filesystem cache when S3 is unavailable - automatic recovery)
# - Cost: ~$0.001/month for S3 storage
#
# LIMITATIONS:
# - Let's Encrypt rate limits: 50 certificates per domain per week
# - Requires port 80 for HTTP-01 challenges (cannot be changed)
# - Only supports HTTP-01 challenge (no DNS-01 for wildcard certificates yet)


# CLUSTER CONFIGURATION
# =============================================================================
# Distributed coordination using gossip protocol (HashiCorp memberlist)
# for leader election and cluster membership management.
#
# USE CASE: When running multiple Sora instances with Let's Encrypt TLS,
# cluster mode ensures only ONE node requests certificates from Let's Encrypt
# at a time, preventing rate limit issues and duplicate certificate requests.
#
# ARCHITECTURE:
# - Uses gossip protocol for peer discovery and failure detection
# - Leader election based on lexicographically smallest node ID (deterministic)
# - Only the leader node can request new TLS certificates
# - All nodes can read certificates from S3 (shared storage)
# - Automatic failover when leader goes down

[cluster]
enabled = false                                 # Enable cluster mode (default: false)

# --- GOSSIP BIND ADDRESS ---
# CRITICAL: The bind address MUST be a specific IP address that is reachable from other cluster nodes.
# This address is used for:
# 1. Binding the gossip UDP/TCP listener
# 2. Advertising to other cluster nodes (they will connect to this address)
# 3. Broadcasting gossip messages across the cluster
#
# VALID EXAMPLES:
#   addr = "10.10.10.40:7946"         # Specific IP with port (recommended)
#   addr = "10.10.10.40"              # Specific IP (uses port from 'port' field below)
#   addr = "192.168.1.100:7946"       # Private network IP
#
# INVALID (WILL FAIL):
#   addr = "0.0.0.0:7946"             # Cannot use 0.0.0.0 - other nodes cannot reach you
#   addr = "localhost:7946"           # Cannot use localhost - hostname resolution issues
#   addr = "[::]:7946"                # Cannot use :: - IPv6 any address not reachable
#
# TESTING ONLY (works but not for production):
#   addr = "127.0.0.1:7946"           # Loopback - works for single-machine testing only
#   addr = "[::1]:7946"               # IPv6 loopback - works for single-machine testing only
#
# WHY THIS MATTERS:
# The gossip protocol needs to advertise a real IP address to other nodes. When you bind to
# 0.0.0.0 or localhost, memberlist doesn't know what IP address to tell other nodes to connect to.
# Using a specific IP solves this by using the same address for both binding and advertising.
#
# NETWORK REQUIREMENTS:
# - This address must be accessible from all other cluster nodes on both TCP and UDP
# - Firewall rules must allow TCP + UDP traffic on the gossip port (default: 7946)
# - The address must be a network interface that exists on this machine
#
addr = "10.10.10.40:7946"                       # Gossip bind address - MUST be specific IP reachable from other nodes

# --- GOSSIP PORT ---
# Only used if 'addr' does not include a port. If addr="10.10.10.40:7946", this is ignored.
# If addr="10.10.10.40", this port will be appended to create "10.10.10.40:7946".
port = 7946                                     # Gossip port (default: 7946)

node_id = ""                                    # Unique node ID (default: hostname)
peers = []                                      # Initial seed nodes for cluster discovery (e.g., ["node-1.example.com:7946", "node-2.example.com:7946"])
                                                # IMPORTANT: Do NOT include this node's own node_id in the peers list!
                                                # Only list OTHER nodes in the cluster. Self-references will be filtered out
                                                # automatically and a warning will be logged.
secret_key = ""                                 # Cluster encryption key: base64-encoded 32-byte key (REQUIRED for production)
                                                # Generate with: openssl rand -base64 32

# --- GOSSIP EVENT QUEUE SETTINGS ---
# Configure the maximum size of the event queue for gossip broadcasts. Each protocol
# (IMAP, POP3, ManageSieve, LMTP) maintains its own queue of connection events to be
# gossiped to other cluster nodes. When the queue fills up, oldest events are dropped.
#
# RECOMMENDED SIZING:
# - Default (50,000): Suitable for most deployments with <2000 users per proxy
# - Busy servers (100,000+): For >3000 active users or high connection churn
# - Low-traffic (10,000): For small deployments with <500 users
#
# MEMORY IMPACT:
# - ~200 bytes per event × 50,000 × 4 protocols = ~40 MB per proxy server
# - Safe to increase significantly on modern hardware
#
# QUEUE OVERFLOW BEHAVIOR:
# - When full, drops oldest 10% of events and logs a warning
# - Periodic state snapshots (every 60s) recover from any lost events
# - Temporary inconsistency acceptable; eventual consistency guaranteed
#
max_event_queue_size = 50000                    # Max events per protocol queue (default: 50000)

# --- CLUSTER-WIDE AUTH RATE LIMITING ---
# Synchronize authentication rate limiting across cluster nodes via gossip protocol.
# When enabled, failed authentication attempts on one node immediately block the IP
# on all other nodes, providing cluster-wide brute-force protection.
[cluster.rate_limit_sync]
enabled = true                                  # Enable cluster-wide rate limiting (default: true if cluster enabled)
sync_blocks = true                              # Synchronize IP blocks across nodes (default: true)
sync_failure_counts = true                      # Synchronize progressive delay failure counts (default: true)

# --- CLUSTER-WIDE SERVER AFFINITY ---
# Synchronize user-to-backend affinity (sticky sessions) across cluster nodes via gossip.
# When enabled, users are consistently routed to the same backend server across all proxy nodes
# for better cache locality and connection reuse. Affinity automatically updates when backends fail.
# NOTE: Affinity is ONLY for non-prelookup users. Prelookup routes are always authoritative.
[cluster.affinity]
enabled = false                                 # Enable cluster-wide server affinity (default: false)
ttl = "24h"                                     # How long affinity persists (default: "24h")
cleanup_interval = "1h"                         # How often to clean up expired affinities (default: "1h")

# EXAMPLE USAGE (Multi-instance deployment):
# [cluster]
# enabled = true
# addr = "10.10.10.40:7946"                     # Node 1 specific IP (MUST be reachable from peers)
# node_id = "sora-1"                            # Or leave empty to use hostname
# peers = ["10.10.10.41:7946", "10.10.10.42:7946"]  # Only need 1-2 seed nodes, gossip discovers others
# secret_key = "YOUR_BASE64_ENCODED_32_BYTE_SECRET_KEY_HERE"
#
# On node 2, use:
# addr = "10.10.10.41:7946"                     # Node 2 specific IP
# peers = ["10.10.10.40:7946"]                  # List node 1 (or any other node)
#
# On node 3, use:
# addr = "10.10.10.42:7946"                     # Node 3 specific IP
# peers = ["10.10.10.40:7946"]                  # List node 1 (or any other node)

# SETUP STEPS:
# 1. Generate cluster secret key:
#    openssl rand -base64 32
# 2. Configure same secret_key on all nodes (CRITICAL: must match across cluster)
# 3. Set unique node_id for each node (or use default hostname)
# 4. Configure addr with the SPECIFIC IP ADDRESS of each node (NOT 0.0.0.0 or localhost!)
#    - Node 1: addr = "10.10.10.40:7946"
#    - Node 2: addr = "10.10.10.41:7946"
#    - Node 3: addr = "10.10.10.42:7946"
# 5. Specify 1-2 peer nodes for initial discovery (each node lists OTHER nodes, not itself)
# 6. Start all nodes - they will discover each other via gossip
# 7. Verify cluster membership: check logs for "Cluster manager initialized" and member count
#
# FEATURES:
# - Automatic leader election (lexicographically smallest node ID)
# - Peer discovery via gossip protocol (memberlist)
# - Failure detection and automatic failover
# - Encrypted communication (AES-256 when secret_key is set)
# - Zero single point of failure
#
# INTEGRATION WITH TLS:
# When cluster mode is enabled with Let's Encrypt:
# - Only the cluster leader requests new certificates from Let's Encrypt
# - Non-leader nodes read certificates from S3 (shared storage)
# - Prevents Let's Encrypt rate limiting (50 certs/domain/week)
# - Prevents duplicate certificate requests
# - Automatic leadership handoff when leader fails
#
# PORTS:
# - Gossip port (default: 7946): Gossip protocol communication (TCP + UDP)
# - Ensure this port is accessible between all cluster nodes (both TCP and UDP)
# - If using a firewall, allow inbound/outbound TCP + UDP on the gossip port from cluster node IPs
#
# SECURITY:
# - ALWAYS use secret_key in production for encrypted gossip communication
# - Use firewall rules to restrict bind_port access to cluster nodes only
# - Rotate secret_key periodically (requires cluster restart)
#
# MONITORING:
# - Log messages show cluster membership changes
# - Log messages show leader election results
# - Example: "Cluster leader changed: node-1 -> node-2 (this node is leader: false)"


# LOCAL CACHE CONFIGURATION
# =============================================================================
# Local filesystem cache for frequently accessed message bodies, reducing
# S3 API calls and improving performance for recently accessed messages.

[local_cache]
path = "/tmp/sora/cache"      # Filesystem path for cache storage. Must be writable. Fast storage (SSD) recommended.
capacity = "1gb"              # Maximum total cache size (e.g., "100mb", "1gb"). LRU eviction when exceeded.
max_object_size = "5mb"       # Maximum size for individual cached objects. Prevents large messages from dominating cache.
metrics_interval = "5m"       # How often cache hit/miss ratios are stored in the database.
metrics_retention = "30d"     # How long to retain cache metrics in the database.
purge_interval = "12h"        # How often to run cache cleanup (capacity enforcement, stale entry removal).
orphan_cleanup_age = "30d"    # Minimum age before orphaned cache entries (for deleted DB messages) are removed.

# --- CACHE WARMUP ---
# Preload recent messages when users reconnect to improve performance.
enable_warmup = true          # Enable cache warmup on user login.
warmup_message_count = 50     # Number of recent messages to preload per mailbox.
warmup_mailboxes = ["INBOX"]  # Mailboxes to warm up. Most clients check INBOX first. e.g., ["INBOX", "Sent"].
warmup_async = true           # true: warmup happens in background (fast login). false: blocks login.
warmup_timeout = "5m"         # Maximum time allowed for a cache warmup operation.
warmup_interval = "24h"       # Minimum time between warmups for the same user. Prevents warmup on every connection.


# S3 UPLOADER CONFIGURATION
# =============================================================================
# Background worker that handles asynchronous uploads of message bodies
# to S3 storage after messages are initially stored locally.

[uploader]
path = "/tmp/sora/uploads"    # Filesystem path for staging uploads (temporary storage before S3).
batch_size = 20               # Number of messages batched together per upload operation.
concurrency = 10              # Number of concurrent upload workers.
max_attempts = 5              # Maximum retry attempts for failed uploads.
retry_interval = "30s"        # Initial delay between retry attempts (exponential backoff is applied).


# RELAY CONFIGURATION
# =============================================================================
# External relay configuration for SIEVE redirect and vacation response delivery.
# When SIEVE scripts use "redirect" or generate vacation responses, messages are
# sent via this relay instead of directly. Supports SMTP and HTTP relay methods.
#
# The relay queue is ALWAYS enabled when relay is configured. Messages are queued
# to disk and delivered asynchronously with automatic retry on failure.
#
# QUEUE MANAGEMENT:
# Use the sora-admin relay commands to monitor and manage the queue:
#   ./sora-admin relay stats           - Show queue statistics (pending, processing, failed)
#   ./sora-admin relay list            - List messages in queue
#   ./sora-admin relay show --id <id>  - Show detailed message info
#   ./sora-admin relay delete --id <id> --confirm  - Delete message from queue
#   ./sora-admin relay requeue --id <id>           - Move failed message back to pending

[relay]
type = "smtp"                     # Relay type: "smtp" or "http"
smtp_host = "smtp.example.com:587" # SMTP relay hostname and port (required for type="smtp")
# http_url = "https://api.example.com/send"  # HTTP API endpoint (required for type="http")
# http_token = "your-bearer-token"           # Bearer token for HTTP Authorization header

# TLS/STARTTLS configuration (SMTP only)
tls = false                       # Use direct TLS (SMTPS, typically port 465)
tls_verify = true                 # Verify server certificate (recommended: true)
tls_use_starttls = true           # Use opportunistic STARTTLS (typically port 587)
# tls_cert_file = "/path/to/relay-client.crt"  # Client certificate (if relay requires mutual TLS)
# tls_key_file = "/path/to/relay-client.key"   # Client key (if relay requires mutual TLS)

# RELAY QUEUE CONFIGURATION
# The queue is ALWAYS ENABLED when relay is configured.
# Messages are persisted to disk and processed asynchronously with automatic retry.
#
# NOTE: If max_attempts > len(retry_backoff), the last backoff value is used for all remaining attempts.
# Example with current settings below:
#   - Attempts 1-6: Use configured backoff values (1m, 5m, 15m, 1h, 6h, 24h)
#   - Attempts 7-10: All use 24h (last value is repeated)
#   - Total retry time: ~99 hours (4 days) before moving to failed queue

[relay.queue]
path = "/var/spool/sora/relay"    # Queue directory path (default: /var/spool/sora/relay)
worker_interval = "1m"            # How often the worker checks for messages to deliver
batch_size = 100                  # Maximum messages to process per worker tick
concurrency = 5                   # Number of concurrent delivery attempts
max_attempts = 10                 # Maximum delivery attempts before moving to failed queue
retry_backoff = ["1m", "5m", "15m", "1h", "6h", "24h"]  # Exponential backoff schedule

# CIRCUIT BREAKER CONFIGURATION
# Protects against cascading failures when the relay endpoint is down.
# When failures exceed threshold, the circuit opens and stops delivery attempts.
# After timeout, it enters half-open state to test if the endpoint has recovered.
circuit_breaker_threshold = 5     # Consecutive failures before opening circuit (default: 5)
circuit_breaker_timeout = "30s"   # How long to wait before attempting recovery (default: 30s)
circuit_breaker_max_requests = 3  # Max requests in half-open state before closing circuit (default: 3)


# CLEANUP PROCESS CONFIGURATION
# =============================================================================
# Background worker that manages message lifecycle and removes old/deleted
# messages according to configured retention policies.

[cleanup]
grace_period = "14d"          # Recovery window for accidentally deleted messages before permanent removal.
wake_interval = "1h"          # How often the cleanup worker runs.
max_age_restriction = ""      # Max message age before auto-expungement. Empty = no limit. e.g., "90d", "365d".
fts_retention = "730d"        # How long to keep full-text search content in DB. Older messages lose searchability.
auth_attempts_retention = "7d"  # How long to retain authentication attempt logs in the database.
health_status_retention = "30d" # How long to retain health status history in the database.

# AUTHENTICATION CACHE CONFIGURATION
# =============================================================================
# In-memory authentication result caching to reduce database load.
# Particularly useful for:
# - Parallel client connections (mail clients often open 3-5+ IMAP connections)
# - Mitigating DoS attacks from non-existent account lookups
# - Reducing latency for repeated authentication attempts
#
# Security note: Cached credentials are verified on every use. Only successful
# credential lookups are cached temporarily to avoid repeated DB queries.

[auth_cache]
enabled = false              # Enable authentication result caching. Default: false (disabled).
positive_ttl = "30s"         # How long to cache successful authentications. Short TTL recommended for security.
negative_ttl = "5m"          # How long to cache failed authentication attempts (user not found, invalid password).
                            # Longer TTL helps mitigate brute force attacks against non-existent accounts.
max_size = 10000            # Maximum number of cached authentication results. LRU eviction when exceeded.
cleanup_interval = "5m"     # How often to remove expired cache entries and update metrics.


# EXTERNAL RELAY CONFIGURATION
# =============================================================================
# Global configuration for external SMTP/HTTP relay used by Sieve redirect and vacation actions.
# This relay is used by LMTP servers and Admin API for sending messages to external recipients.
#
# Use cases:
#   - Sieve redirect action: forward messages to external email addresses
#   - Sieve vacation action: send auto-reply vacation responses
#
# You can choose between SMTP or HTTP relay:
#   - SMTP: Traditional SMTP relay (most common)
#   - HTTP: HTTP API relay for services that provide REST API for email delivery

[relay]
type = "smtp"                                      # Relay type: "smtp" or "http"

# SMTP Relay Configuration (when type="smtp")
smtp_host = "smtp.example.com:587"                # SMTP relay host and port
smtp_tls = true                                   # Use TLS (recommended: true)
smtp_tls_verify = true                            # Verify TLS certificates (recommended: true)
smtp_use_starttls = true                          # Use STARTTLS (port 587) instead of direct TLS (port 465)
# smtp_tls_cert_file = "/path/to/client.crt"     # Client certificate for mTLS (optional)
# smtp_tls_key_file = "/path/to/client.key"      # Client key for mTLS (optional)

# HTTP API Relay Configuration (when type="http")
# http_url = "https://api.example.com/v1/mail/deliver"  # HTTP API endpoint
# auth_token = "your-bearer-token"                      # Bearer token for Authorization header

# Common relay providers:
#   Gmail: smtp.gmail.com:587 (requires app-specific password)
#   SendGrid: smtp.sendgrid.net:587 (API key as password)
#   Mailgun: smtp.mailgun.org:587 (API credentials)
#   Amazon SES: email-smtp.us-east-1.amazonaws.com:587 (SMTP credentials)

# RELAY QUEUE CONFIGURATION
# =============================================================================
# Disk-based queue for relay delivery with automatic retry on failure.
# The queue is ALWAYS ENABLED when relay is configured (see [relay] section above).
# Messages are queued to disk and processed by background worker with exponential backoff.
# This prevents message loss if external relay is temporarily unavailable.
#
# Benefits:
#   - No message loss if relay fails temporarily
#   - Exponential backoff retry mechanism
#   - Circuit breaker protection (automatic fail-fast when endpoint is down)
#   - Persistent across server restarts
#   - No database overhead for non-critical relay messages
#
# Circuit Breaker:
#   The relay handler includes an automatic circuit breaker that:
#   - Opens after 5 consecutive failures (stops attempting delivery)
#   - Tries recovery after 30 seconds (half-open state)
#   - Closes after successful deliveries (normal operation resumed)
#   - Prevents resource waste when external relay is down
#   - Visible in health checks as circuit_breaker_smtp_relay or circuit_breaker_http_relay
#
# Directory structure:
#   {path}/pending/    - Messages waiting for delivery
#   {path}/processing/ - Currently being processed
#   {path}/failed/     - Exceeded max_attempts, requires manual intervention
#
# Management: Use `sora-admin relay` commands to inspect and manage the queue
#
# NOTE: If max_attempts > len(retry_backoff), the last backoff value is used for all remaining attempts.
#       Example: With 6 backoff values and 10 max_attempts, attempts 7-10 will all use the 6th backoff (24h).

[relay.queue]
path = "/var/spool/sora/relay"                                    # Base path for queue storage (default: /var/spool/sora/relay)
worker_interval = "1m"                                            # How often worker processes queue (default: 1m)
batch_size = 100                                                  # Number of messages to process per worker cycle (default: 100)
concurrency = 5                                                   # Number of concurrent messages to process (default: 5)
max_attempts = 10                                                 # Maximum delivery attempts before moving to failed (default: 10)
retry_backoff = ["1m", "5m", "15m", "1h", "6h", "24h"]           # Backoff durations between retries (exponential, default shown)
                                                                  # With these 6 values and 10 max_attempts:
                                                                  # Attempts 1-6 use the configured backoff values
                                                                  # Attempts 7-10 all use 24h (last value is repeated)
                                                                  # Total retry time: ~1m+5m+15m+1h+6h+24h+24h+24h+24h ≈ 99 hours (4 days)

# Circuit Breaker Configuration
circuit_breaker_threshold = 5                                     # Consecutive failures before opening circuit (default: 5)
circuit_breaker_timeout = "30s"                                   # Recovery test interval (default: 30s)
circuit_breaker_max_requests = 3                                  # Max requests allowed in half-open state (default: 3)


# METADATA LIMITS CONFIGURATION
# =============================================================================
# IMAP METADATA extension (RFC 5464) limits to prevent storage abuse.
# These limits apply per-account and help protect against excessive metadata usage.
#
# NOTE: "server-level" (SETMETADATA "") means account-level metadata (global, not mailbox-specific).
#       "mailbox-level" (SETMETADATA "INBOX") means per-mailbox metadata.

[metadata]
max_entry_size = 65536         # Maximum size per metadata entry (64KB). Prevents huge single values.
max_entries_per_mailbox = 1000 # Maximum number of metadata entries per mailbox (mailbox-level).
max_entries_per_server = 1000  # Maximum number of account-level metadata entries (server-level).
max_total_size = 1048576       # Maximum total metadata size per account (1MB). Overall quota protection.


# SHARED MAILBOXES CONFIGURATION
# =============================================================================
# Enable shared mailboxes for collaboration between users on the same domain.
# Uses IMAP namespace extension (RFC 2342) for proper client support.
# Implements Access Control Lists (RFC 4314) for fine-grained permissions.

[shared_mailboxes]
enabled = false                  # Enable shared mailbox functionality (default: false)
namespace_prefix = "Shared/"     # IMAP namespace prefix for shared mailboxes (e.g., "Shared/" or "#shared/")
allow_user_create = false        # Allow regular users to create shared mailboxes (false = admin-only)
default_rights = "lrswipkxtea"   # Default ACL rights for shared mailbox creators (full rights by default)
                                # Rights: l=lookup, r=read, s=seen, w=write, i=insert, p=post, k=create, x=delete, t=delete-msg, e=expunge, a=admin

# IMPORTANT NOTES:
# - Shared mailboxes are restricted to users within the same domain for security
# - Creators automatically receive the default_rights on mailboxes they create
# - Additional users must be granted access via IMAP ACL commands or admin API
# - The NAMESPACE command will advertise the shared namespace when enabled


# TIMEOUT SCHEDULER CONFIGURATION
# =============================================================================
# Global timeout scheduler configuration for connection timeout management.
# The scheduler uses sharding to efficiently check timeouts across many connections.

[timeout_scheduler]
# Number of shards for parallel timeout checking. More shards = better scalability for high connection counts.
# - 0: Default - uses runtime.NumCPU() logical cores (includes hyperthreading)
# - -1: Physical cores - uses runtime.NumCPU()/2 (approximates physical cores)
# - >0: Custom - uses specified number of shards
#
# RECOMMENDATIONS:
# - Default (0): Best for most deployments, balances CPU usage and responsiveness
# - Physical cores (-1): Use if hyperthreading causes contention issues
# - Custom (>0): Use for fine-tuning in specific scenarios (e.g., 4, 8, 16)
#
# Each shard runs an independent goroutine checking connections every 100ms.
# Memory usage: ~200KB per shard. CPU usage: minimal during low activity.
shard_count = 0  # Default: 0 (runtime.NumCPU())

# GLOBAL SERVERS CONFIGURATION
# =============================================================================
# Global settings that apply to all protocol servers.

[servers]
# Note: Debug logging is now configured per-server using the 'debug' option on individual servers

# --- TRUSTED NETWORKS ---
# Networks trusted for proxy parameter forwarding (XCLIENT, ID commands, etc.)
# These networks can forward client information through proxy protocols
trusted_networks = ["127.0.0.0/8", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "::1/128"]


# DYNAMIC SERVER CONFIGURATION
# =============================================================================
# Sora now uses a dynamic server configuration system that allows you to define
# multiple servers of any type with individual configurations. Each server is
# defined as a [[server]] section with a unique name and configuration.
#
# Server Types:
# - imap: IMAP4rev1 server for email access
# - lmtp: Local Mail Transfer Protocol for mail delivery
# - pop3: POP3 server for email download
# - managesieve: ManageSieve server for SIEVE script management
# - imap_proxy: IMAP proxy server for load balancing
# - pop3_proxy: POP3 proxy server for load balancing
# - managesieve_proxy: ManageSieve proxy server for load balancing
# - lmtp_proxy: LMTP proxy server for load balancing
# - metrics: Prometheus metrics HTTP endpoint
# - http_admin_api: REST API server for administrative operations
#
# IMPORTANT: You must configure at least one server for Sora to start.

# IMAP SERVER EXAMPLE
# =============================================================================
# Internet Message Access Protocol - primary protocol for email access
# Supports IMAP4rev1 with IDLE extension for real-time notifications.

[[server]]
type = "imap"
name = "main-imap"            # Unique server name for identification
addr = ":143"                 # Listen address and port. Use :993 for IMAPS.
debug = false                 # Enable debug logging for this IMAP server

# --- CONNECTION LIMITING AND MEMORY MANAGEMENT ---
max_connections = 1000        # Maximum concurrent IMAP connections to this server instance.
max_connections_per_ip = 10   # Max connections per client IP. Set to 0 if behind a load balancer.
listen_backlog = 4096         # TCP listen backlog size (0 = default 1024). Prevents connection delays under high load.
                              # FreeBSD/Linux default is often too small (~128-512). Recommended: 4096-8192 for high-load servers.
                              # Small backlog causes SYN queue to fill, leading to ~60s connection delays.

# --- IMAP-SPECIFIC CONFIGURATION ---
append_limit = "25mb"         # Maximum message size for IMAP APPEND. Empty = no limit.

# --- MASTER USER AUTHENTICATION ---
master_username = ""          # Master username for administrative IMAP access (e.g., for proxies).
master_password = ""          # Password for master_username.
master_sasl_username = ""     # Alternative master username for SASL authentication.
master_sasl_password = ""     # Password for master_sasl_username.

# --- TLS/SSL CONFIGURATION ---
# TWO OPTIONS:
# 1. Use global TLS manager (see [tls] section above) - recommended for Let's Encrypt
#    Set tls=true and OMIT tls_cert_file/tls_key_file (they will be ignored)
# 2. Use per-server certificates (only if global [tls] enabled=false)
#    Set tls=true AND provide tls_cert_file/tls_key_file below
tls = false                               # Enable TLS for IMAP (IMAPS). Typically on port 993.
# tls_cert_file = "/path/to/your/imap.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/imap.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false                        # Verify client certificates (mutual TLS). Usually false.
# tls_default_domain = "imap.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this server.
                                          # Useful when different protocols should have different default certificates
                                          # (e.g., imap.example.com for IMAP, pop3.example.com for POP3).
                                          # If not set, uses global [tls.letsencrypt].default_domain or first domain in list.

# --- PROXY PROTOCOL CONFIGURATION ---
# Enable if this server is behind a load balancer or reverse proxy
proxy_protocol = false            # Enable PROXY protocol support (HAProxy, nginx, etc.)
proxy_protocol_timeout = "5s"     # Timeout for reading PROXY protocol headers

# --- GLOBAL CAPABILITY CONFIGURATION ---
# Disable specific IMAP capabilities for ALL clients connecting to this server.
# Disabled capabilities are not announced in CAPABILITY responses and cannot be used.
#
# This is different from client_filters which apply based on client identity.
# Use this when you want to disable capabilities for ALL clients on this server.
#
# Common capabilities that can be disabled:
# - ESEARCH: Extended search (RFC 4731)
# - CONDSTORE: Conditional STORE (RFC 7162)
# - IDLE: Push notifications (RFC 2177)
# - MOVE: Efficient message moving (RFC 6851)
# - COMPRESS: DEFLATE compression (RFC 4978)
# - SORT/ESORT: Server-side sorting
#
# disabled_caps = ["ESEARCH", "CONDSTORE", "IDLE"]  # Example: disable these capabilities globally
#
# NOTE: Do not disable core capabilities like IMAP4rev1, STARTTLS, or AUTH=PLAIN
# as this will break basic IMAP functionality.

# --- CLIENT CAPABILITY FILTERS ---
# Disable specific IMAP capabilities for problematic clients based on their ID or TLS fingerprint
# This helps work around client bugs while maintaining full functionality for well-behaved clients
# Note: Filtered capabilities are removed from CAPABILITY responses and command handlers reject their use

# Match by client name (from IMAP ID command)
# [[server.client_filters]]
# client_name = "com\\.apple\\.email\\.maild"  # iOS Apple Mail (regex pattern)
# client_version = ".*"                        # Any version
# disable_caps = ["CONDSTORE"]                 # Capabilities to disable
# reason = "iOS Apple Mail has CONDSTORE implementation issues"

# Match by client name and version
# [[server.client_filters]]
# client_name = "Microsoft Outlook"            # Outlook for Windows/Mac
# client_version = "16\\..*"                   # Only version 16.x
# disable_caps = ["IDLE", "CONDSTORE"]         # Multiple capabilities
# reason = "Outlook 16.x has connection issues with IDLE and CONDSTORE"

# Match by JA4 TLS fingerprint (requires TLS or PROXY protocol with JA4 TLV)
# Useful for filtering before client sends ID command, or when client doesn't send ID
# [[server.client_filters]]
# ja4_fingerprints = ["^t13d1516h2_8daaf6152771_.*"]  # Single JA4 pattern (as array)
# disable_caps = ["ESEARCH", "IDLE"]
# reason = "Client with this TLS fingerprint has issues"

# Match by multiple JA4 fingerprints (one client may have different fingerprints)
# [[server.client_filters]]
# client_name = "com\\.apple\\.email\\.maild"
# client_version = ".*"
# ja4_fingerprints = [
#   "^t13d411100_6be44479b708_.*",  # iOS with one network config
#   "^t13d2014ip_a09f3c656075_.*",  # iOS with IPv6
#   "^t13i201200_a09f3c656075_.*",  # iOS with different cipher preference
# ]
# disable_caps = ["ESEARCH", "CONDSTORE", "IDLE"]
# reason = "iOS Apple Mail has implementation issues (multiple fingerprints)"

# Matching logic:
# - If ja4_fingerprints specified: matches if ANY pattern matches (OR)
# - If client_name/version specified: matches if BOTH name AND version match (AND)
# - Between ja4_fingerprints and client_name/version: matches if EITHER criteria is met (OR)

# --- RESOURCE LIMITS ---
# Search rate limiting - prevent DoS attacks via excessive search queries (IMAP only)
limits.search_rate_limit_per_min = 30    # Maximum searches per minute per user (default: 30, set to 0 to disable).
limits.search_rate_limit_window = "1m"   # Time window for search rate limiting (default: "1m").

# --- TIMEOUT CONFIGURATION ---
# Multi-layered timeout protection against various DoS attacks
timeouts.command_timeout = "5m"             # Maximum idle time before disconnection (e.g., "5m", default: 5 minutes for IMAP)
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration regardless of activity (e.g., "30m", default: 30 minutes)
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)

# --- AUTHENTICATION RATE LIMITING ---
# Use dotted notation for nested config within [[server]] array element
auth_rate_limit.enabled = false                   # Enable authentication rate limiting.
auth_rate_limit.max_attempts_per_ip = 10          # Max failed auth attempts per IP address.
auth_rate_limit.max_attempts_per_username = 5     # Max failed auth attempts per username (across all IPs).
auth_rate_limit.ip_window_duration = "15m"        # Time window for IP-based rate limiting.
auth_rate_limit.username_window_duration = "30m"  # Time window for username-based rate limiting.
auth_rate_limit.cleanup_interval = "5m"           # How often to clean up expired rate limiting data.
auth_rate_limit.fast_block_threshold = 10         # Failed attempts before immediate IP blocking.
auth_rate_limit.fast_block_duration = "5m"        # Duration of the fast IP block.
auth_rate_limit.delay_start_threshold = 2         # Failed attempts before applying authentication delays.
auth_rate_limit.initial_delay = "2s"              # Initial authentication delay after threshold is reached.
auth_rate_limit.max_delay = "30s"                 # Maximum authentication delay.
auth_rate_limit.delay_multiplier = 2.0            # Multiplier for progressive delay (exponential backoff).
auth_rate_limit.cache_cleanup_interval = "1m"     # How often to clean up expired in-memory cache entries.
auth_rate_limit.db_sync_interval = "30s"          # How often to sync batched auth attempts to the database.
auth_rate_limit.max_pending_batch = 100           # Max pending auth attempts before forcing a DB sync.
auth_rate_limit.db_error_threshold = "1m"         # Time to wait before retrying DB operations after an error.


# LMTP SERVER EXAMPLE
# =============================================================================
# Local Mail Transfer Protocol - handles incoming mail delivery from MTAs
#
# NOTE: Uses global [relay] configuration for Sieve redirect/vacation actions.
#
# Multi-server LMTP example:
# [[server]]
# type = "lmtp"
# name = "production-lmtp"
# addr = ":24"
#
# [[server]]
# type = "lmtp"
# name = "test-lmtp"
# addr = ":2424"

[[server]]
type = "lmtp"
name = "main-lmtp"
addr = ":24"
debug = true                  # Enable debug logging for LMTP server
max_connections = 500
max_connections_per_ip = 5
tls = false
tls_use_starttls = false      # Use STARTTLS for opportunistic encryption.
# tls_cert_file = "/path/to/your/lmtp.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/lmtp.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false
# tls_default_domain = "lmtp.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this server.
proxy_protocol = false        # Enable PROXY protocol support for LMTP
proxy_protocol_timeout = "5s"

# --- MESSAGE SIZE LIMITING ---
# Maximum size for incoming LMTP messages to prevent memory exhaustion attacks
max_message_size = "50mb"     # Maximum message size (default: 50MB, 0 = unlimited)

# NOTE: External relay for Sieve redirect/vacation is configured globally in [relay] section above


# POP3 SERVER EXAMPLE
# =============================================================================
# Post Office Protocol version 3 - legacy protocol for downloading email

[[server]]
type = "pop3"
name = "main-pop3"
addr = ":110"                 # Use :995 for POP3S.
max_connections = 500
max_connections_per_ip = 5
master_sasl_username = ""
master_sasl_password = ""
tls = false
# tls_cert_file = "/path/to/your/pop3.crt"  # [OPTIONAL] Only needed if global [tls] is disabled
# tls_key_file = "/path/to/your/pop3.key"   # [OPTIONAL] Only needed if global [tls] is disabled
tls_verify = false
# tls_default_domain = "pop3.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this server.
proxy_protocol = false        # Enable PROXY protocol support for POP3
proxy_protocol_timeout = "5s"

# --- AUTHENTICATION RATE LIMITING ---
# Same configuration available as shown in IMAP example above
# auth_rate_limit.enabled = false

# --- TIMEOUT CONFIGURATION ---
timeouts.command_timeout = "2m"             # Maximum idle time before disconnection (default: 2 minutes for POP3)
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes)
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)


# MANAGESIEVE SERVER EXAMPLE
# =============================================================================
# ManageSieve protocol for managing SIEVE mail filtering scripts

[[server]]
type = "managesieve"
name = "main-managesieve"
addr = ":4190"
max_connections = 200
max_connections_per_ip = 3
max_script_size = "16kb"      # Maximum size for a SIEVE script.
# Supported SIEVE extensions that scripts can use via "require" statement.
# This list controls which extensions are validated and allowed when scripts are uploaded.
#
# IMPORTANT: Extensions listed here will be advertised to clients in CAPABILITY responses.
# Clients can then use "require 'extension'" in their scripts, and scripts using those
# extensions will be accepted during PUTSCRIPT validation.
#
# Available extensions that go-sieve supports:
#   - fileinto, envelope, encoded-character, imap4flags, variables, relational, copy, regex, vacation
#   - comparator-i;octet, comparator-i;ascii-casemap, comparator-i;ascii-numeric, comparator-i;unicode-casemap
#
# DEFAULT BEHAVIOR: If supported_extensions is not specified (commented out or empty),
# ALL available extensions listed above will be enabled by default.
#
# Common production configuration (explicitly limiting to commonly used extensions):
supported_extensions = ["fileinto", "vacation", "envelope", "imap4flags", "variables", "relational", "copy", "regex"]
#
# To enable ALL extensions, simply comment out or remove the supported_extensions line above.
insecure_auth = false                            # Allow plaintext auth. SECURITY: Should be false in production.
master_sasl_username = ""
master_sasl_password = ""
tls = false
tls_use_starttls = false
# tls_default_domain = "managesieve.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this server.
tls_cert_file = "/path/to/your/managesieve.crt"
tls_key_file = "/path/to/your/managesieve.key"
tls_verify = true
proxy_protocol = false        # Enable PROXY protocol support for ManageSieve
proxy_protocol_timeout = "5s"

# --- AUTHENTICATION RATE LIMITING ---
# Same configuration available as shown in IMAP example above
# auth_rate_limit.enabled = false

# --- TIMEOUT CONFIGURATION ---
timeouts.command_timeout = "3m"             # Maximum idle time before disconnection (default: 3 minutes for ManageSieve)
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes)
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)


# IMAP PROXY EXAMPLE
# =============================================================================
# Proxy IMAP connections across multiple backend servers with load balancing

[[server]]
type = "imap_proxy"
name = "imap-proxy-1"
addr = ":1143"                # Proxy listen address. Must be different from backend IMAP port.
remote_addrs = ["backend1.example.com:143", "backend2.example.com:143", "backend3.example.com:143"]
max_connections = 2000                # Max connections to this proxy instance
max_connections_per_ip = 50           # Max connections per client IP
max_connections_per_user = 0          # Cluster-wide limit per user (requires cluster mode, 0 = unlimited)
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = true
# tls_default_domain = "imap.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this proxy.

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_id_command = false         # Send IMAP ID command to backends

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
auth_idle_timeout = "2m"        # Idle timeout between commands during authentication phase (pre-auth only).
                              # Resets after each command received. If client is silent for 2 minutes, disconnected.
                              # Cleared after successful authentication.
                              # Note: absolute_session_timeout (below) separately limits total session duration.
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- TIMEOUT CONFIGURATION ---
# IMPORTANT: IMAP proxy cannot detect IDLE commands (RFC 2177), so command_timeout should be disabled (0).
#
# IMAP proxy has THREE timeout mechanisms:
# 1. auth_idle_timeout (above): Idle timeout during pre-auth phase only
#    - Resets after each command received
#    - 2 minutes of silence during login → disconnect
#    - Cleared after successful authentication
#
# 2. command_timeout (below): Idle timeout that applies during entire connection
#    - MUST be disabled (0) for IMAP proxy because:
#      - IDLE commands can legitimately last 29+ minutes (RFC 2177)
#      - Proxy is protocol-agnostic and cannot detect IDLE
#      - Backend IMAP server handles IDLE correctly with its own timeouts
#    - Pre-auth protection is already provided by session_timeout above
#
# 3. absolute_session_timeout (below): Maximum total session duration
#    - Enforced throughout entire connection (pre-auth AND post-auth)
#    - Prevents indefinitely long sessions
#    - 30 minutes from connection to disconnection, regardless of activity
#
timeouts.command_timeout = "0"              # Idle timeout. Set to "0" to disable (REQUIRED for IMAP proxy).
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration from connect to disconnect.
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)

# --- HTTP-BASED USER ROUTING (PRELOOKUP) ---
# Advanced feature for routing users to specific backend servers via HTTP API.
#
# The prelookup service is called via HTTP GET with email interpolation.
# The URL can contain $email placeholder which is replaced with the URL-encoded email address.
#
# Example URLs:
#   "http://localhost:8080/lookup?email=$email" → GET /lookup?email=user@domain.com
#   "http://localhost:8080/user/$email/info"    → GET /user/user@domain.com/info
#
# The HTTP endpoint should return a JSON response with the following fields:
#
# REQUIRED FIELDS:
# - address: Email address for backend impersonation (string)
# - password_hash: Password hash to verify authentication (string)
# - server: Backend server address - can be IP/hostname:port OR just IP/hostname (string)
#   * If port is included: "192.168.1.10:143" or "backend.example.com:993"
#   * If port is omitted: "192.168.1.10" or "backend.example.com"
#     → Port from remote_port config will be appended (default: 143)
# - account_id: Account ID for tracking/metrics (integer, must be > 0)
#
# Example JSON Response (with port):
# {
#   "address": "user@domain.com",
#   "password_hash": "$2a$12$abcdef...",
#   "server": "backend1.example.com:143",
#   "account_id": 12345
# }
#
# Example JSON Response (without port - uses remote_port):
# {
#   "address": "user@domain.com",
#   "password_hash": "$2a$12$abcdef...",
#   "server": "192.168.1.10",
#   "account_id": 12345
# }
#
# BEHAVIOR:
# - HTTP GET request is made for each authentication attempt
# - Circuit breaker protects against service failures (60% failure rate triggers open state)
# - Password formats: bcrypt ($2a$...), SSHA512 ({SSHA512}...), SHA512 ({SHA512}...), BLF-CRYPT ($2b$...)
# - If HTTP endpoint returns 404 or 5xx → falls back to default routing (if fallback_to_default=true)
# - If HTTP endpoint returns 200 with data but auth fails → connection REJECTED (no fallback)
# - Server addresses normalized: missing ports use remote_port default (e.g., 143 for IMAP)
# - Timeout for HTTP requests is configurable (default: 5s)
#
# ALIAS RESOLUTION:
# The "address" field in the response is used for backend impersonation. This enables alias resolution:
# - Request: user logs in with "alias@domain.com"
# - Response: {"address": "realuser@domain.com", ...}
# - Proxy connects to backend and authenticates as "realuser@domain.com"
#
[server.prelookup]
enabled = false                             # Enable/disable HTTP-based user routing.
url = "http://localhost:8080/lookup?email=$email"  # HTTP endpoint URL with $email placeholder (required if enabled)
                                            # The $email placeholder is replaced with the URL-encoded email address
                                            # Examples:
                                            #   "http://localhost:8080/lookup?email=$email" → query parameter
                                            #   "http://localhost:8080/user/$email/lookup" → path parameter
                                            #   "http://localhost:8080/api/v1/auth?user=$email&format=json" → custom format
timeout = "5s"                              # HTTP request timeout (default: 5s)
# auth_token = "your-secret-token"          # Bearer token for HTTP authentication (optional)
                                            # If set, sends "Authorization: Bearer <token>" header with requests
                                            # Use this to secure your prelookup endpoint

fallback_to_default = true            # If prelookup initialization fails (e.g., endpoint unreachable), continue without prelookup
                                      # using default round-robin routing. If false, proxy fails to start on prelookup errors.
                                      # NOTE: This only applies to initialization failures, not per-user lookup failures.
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
                                      # NOTE: Only supported for LMTP and ManageSieve proxies.
                                      #       IMAP and POP3 proxies use implicit TLS and ignore this setting.
remote_tls_verify = true              # Verify backend TLS certificates
# remote_port = 143                   # Default port to append if server address doesn't include port (default: 143)
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_id_command = false         # Send IMAP ID command to backends (IMAP only)

  # --- PRELOOKUP CACHING ---
  # In-memory caching of HTTP prelookup results for improved performance.
  # Significantly reduces HTTP requests by caching authentication results.
  #
  # CACHE BEHAVIOR:
  # - Positive results (successful auth): Cached with longer TTL
  # - Negative results (failed auth, user not found): Cached with shorter TTL
  # - Cache key: Combination of email and password hash
  # - Thread-safe with read/write locks
  # - Background cleanup of expired entries
  # - LRU-style eviction when max size exceeded
  #
  # BENEFITS:
  # - Reduced latency: Sub-millisecond cache lookups vs HTTP roundtrip
  # - Reduced load: Fewer requests to prelookup HTTP endpoint
  # - DDoS protection: Negative caching prevents repeated failed auth attempts
  # - Configurable: Separate TTLs for positive/negative results
  #
  # EXAMPLE SCENARIOS:
  # - User authenticates successfully → cached for 5 minutes
  # - Same user authenticates again within 5 minutes → instant cache hit
  # - Attacker tries wrong password → cached as failed for 1 minute
  # - Attacker retries same wrong password → instant rejection from cache
  #
  # [server.prelookup.cache]
  # enabled = false                 # Enable in-memory caching of prelookup results (default: false)
  # positive_ttl = "5m"             # TTL for successful authentication (default: 5m)
                                    # How long to cache valid credentials
                                    # Longer TTL = fewer HTTP requests, but password changes take longer to take effect
  # negative_ttl = "1m"             # TTL for failed auth or user not found (default: 1m)
                                    # Shorter TTL avoids caching temporary issues (e.g., typos, transient failures)
                                    # Provides DDoS protection while allowing quick recovery
  # max_size = 10000                # Maximum number of cached entries (default: 10000)
                                    # When exceeded, oldest entries (by expiration time) are evicted
                                    # Memory usage: ~1-2 KB per entry, so 10000 entries ≈ 10-20 MB
  # cleanup_interval = "1m"         # How often to scan and remove expired entries (default: 1m)
                                    # More frequent = lower memory usage, slightly higher CPU
                                    # Less frequent = higher memory usage, lower CPU

  # --- CIRCUIT BREAKER FOR PRELOOKUP ENDPOINT ---
  # Protects the system from cascading failures when the HTTP prelookup endpoint becomes unavailable.
  # When the endpoint starts failing (timeouts, 5xx errors, network issues), the circuit breaker
  # automatically "opens" to prevent further requests and allow the service to recover.
  #
  # CIRCUIT BREAKER STATES:
  # - CLOSED: Normal operation, all requests go through
  # - OPEN: Endpoint is failing, all requests rejected immediately (respects fallback_to_default)
  # - HALF-OPEN: Testing recovery, limited requests allowed to check if endpoint recovered
  #
  # RECOVERY PROCESS:
  # 1. Circuit opens after failure_ratio threshold reached (default: 60% of last 3 requests fail)
  # 2. Waits for timeout period (default: 30s)
  # 3. Transitions to half-open and allows max_requests concurrent test requests (default: 3)
  # 4. If tests succeed → circuit closes and normal operation resumes
  # 5. If tests fail → circuit re-opens and waits another timeout period
  #
  # IMPORTANT: Only server errors (5xx), timeouts, and network failures trigger the circuit breaker.
  # Valid responses like 404 (user not found) do NOT count as failures.
  #
  # PRODUCTION RECOMMENDATIONS:
  # - timeout: 60s-300s (longer allows more time for service recovery)
  # - max_requests: 5-10 (more requests = better confidence in recovery)
  # - min_requests: 5-10 (avoids opening circuit on brief hiccups)
  # - failure_ratio: 0.6-0.8 (60-80% failure rate before opening)
  #
  # [server.prelookup.circuit_breaker]
  # max_requests = 3                # Maximum concurrent requests in half-open state (default: 3)
                                    # Higher values = more confidence that service recovered before closing circuit
                                    # Lower values = faster recovery but may close prematurely
  # timeout = "30s"                 # Time to wait before transitioning from open to half-open (default: 30s)
                                    # How long to wait before testing if the service recovered
                                    # Production: Consider 60s-300s to give services time to recover
  # interval = "0s"                 # Time before resetting failure counts in closed state (default: 0s = never reset)
                                    # Set to non-zero to allow "forgetting" old failures
                                    # Example: "60s" = after 60s of no requests, reset failure counters
  # failure_ratio = 0.6             # Failure ratio threshold to open circuit (0.0-1.0, default: 0.6 = 60%)
                                    # Circuit opens when this percentage of recent requests fail
                                    # Production: Consider 0.7-0.8 for less sensitive triggering
  # min_requests = 3                # Minimum requests before evaluating failure ratio (default: 3)
                                    # Prevents opening circuit on very few requests
                                    # IMPORTANT: Should be ≤ max_requests to avoid getting stuck
                                    # Production: Consider 5-10 for more stable thresholds

  # --- HTTP TRANSPORT CONFIGURATION ---
  # Connection pooling settings for the HTTP client used to query the prelookup endpoint.
  # Proper connection pooling enables parallel authentication requests while reusing connections.
  #
  # TRANSPORT BEHAVIOR:
  # - Multiple concurrent authentication requests reuse pooled HTTP connections
  # - Idle connections are kept alive to avoid TCP handshake overhead
  # - Unlimited concurrent connections per host (max_conns_per_host=0) for high throughput
  #
  # PERFORMANCE IMPACT:
  # - Higher max_idle_conns = more connections kept alive = faster subsequent requests
  # - max_conns_per_host=0 (unlimited) = no bottleneck for concurrent auth requests
  # - Longer idle_conn_timeout = fewer reconnects = better performance under load
  #
  # EXAMPLE SCENARIOS:
  # - 100 concurrent user logins → reuses up to 100 idle connections from pool
  # - Low traffic → connections automatically closed after idle_conn_timeout
  # - High traffic → connections stay warm and reused immediately
  #
  # [server.prelookup.transport]
  # max_idle_conns = 100            # Maximum idle connections across all hosts (default: 100)
                                    # Total number of connections kept alive in the pool
                                    # Higher = more connections reused, less overhead
  # max_idle_conns_per_host = 100   # Maximum idle connections per prelookup host (default: 100)
                                    # For single prelookup endpoint, should match max_idle_conns
                                    # For multiple endpoints, distributes pool across hosts
  # max_conns_per_host = 0          # Maximum total connections per host, 0=unlimited (default: 0)
                                    # Set to 0 (unlimited) for best parallel performance
                                    # Only limit if prelookup endpoint has connection restrictions
  # idle_conn_timeout = "90s"       # How long idle connections stay open (default: "90s")
                                    # Longer = better for sustained traffic, more memory
                                    # Shorter = less memory, more reconnects under load

# --- MASTER TOKEN / ALIAS RESOLUTION ---
# The HTTP endpoint can implement master token authentication or alias resolution.
# The proxy simply passes the full email address to the endpoint and verifies the returned password hash.
#
# Example: Master Token Authentication
# - Client logs in with: email="user@domain.com@MASTERTOKEN", password="anything"
# - HTTP GET request: /lookup?email=user@domain.com@MASTERTOKEN
# - HTTP endpoint splits the email, validates the token, and returns:
#   {
#     "address": "user@domain.com",
#     "password_hash": "<hash of MASTERTOKEN>",
#     "server": "backend1:143",
#     "account_id": 123
#   }
# - Proxy verifies "anything" against the returned hash
# - Proxy connects to backend as "user@domain.com" (from "address" field)
#
# Example: Alias Resolution
# - Client logs in with: email="alias@domain.com", password="userpass"
# - HTTP GET request: /lookup?email=alias@domain.com
# - HTTP endpoint resolves alias and returns:
#   {
#     "address": "realuser@domain.com",
#     "password_hash": "<hash of userpass>",
#     "server": "backend1:143",
#     "account_id": 456
#   }
# - Proxy verifies "userpass" against the returned hash
# - Proxy connects to backend as "realuser@domain.com" (from "address" field)
#
# The "address" field in the HTTP response determines which user the proxy authenticates as on the backend.
# All logic for token splitting, validation, alias resolution, etc. is handled by your HTTP endpoint.
#
# See test_prelookup_server.go for a working example implementation.


# POP3 PROXY EXAMPLE
# =============================================================================
# Proxy POP3 connections across multiple backend servers with load balancing

[[server]]
type = "pop3_proxy"
name = "pop3-proxy-1"
addr = ":1110"                # Proxy listen address. Must be different from backend POP3 port.
remote_addrs = ["backend1.example.com:110", "backend2.example.com:110"]
max_connections = 1000
max_connections_per_ip = 20
max_connections_per_user = 0          # Cluster-wide limit per user (requires cluster mode, 0 = unlimited)
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_cert_file = ""
tls_key_file = ""
tls_verify = true
# tls_default_domain = "pop3.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this proxy.

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_xclient = false            # Send XCLIENT command to backends for forwarding client info

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
auth_idle_timeout = "2m"        # Idle timeout between commands during authentication phase (pre-auth only).
                              # Resets after each command received. Cleared after successful authentication.
                              # Note: absolute_session_timeout (below) separately limits total session duration.
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- TIMEOUT CONFIGURATION ---
timeouts.command_timeout = "5m"             # Maximum idle time (default: 5 minutes)
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes)
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# MANAGESIEVE PROXY EXAMPLE
# =============================================================================
# Proxy ManageSieve connections across multiple backend servers

[[server]]
type = "managesieve_proxy"
name = "managesieve-proxy-1"
addr = ":14190"               # Proxy listen address. Must be different from backend ManageSieve port.
remote_addrs = ["backend1.example.com:4190", "backend2.example.com:4190"]
max_connections = 500
max_connections_per_ip = 10
max_connections_per_user = 0          # Cluster-wide limit per user (requires cluster mode, 0 = unlimited)
insecure_auth = false                 # Allow plaintext auth. SECURITY: Should be false in production.
master_sasl_username = "proxyuser"
master_sasl_password = "proxypass"

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_use_starttls = false              # Use STARTTLS on listening port (client connections)
tls_cert_file = ""
tls_key_file = ""
tls_verify = true
# tls_default_domain = "managesieve.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this proxy.

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
auth_idle_timeout = "2m"        # Idle timeout between commands during authentication phase (pre-auth only).
                              # Resets after each command received. Cleared after successful authentication.
                              # Note: absolute_session_timeout (below) separately limits total session duration.
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- TIMEOUT CONFIGURATION ---
timeouts.command_timeout = "5m"             # Maximum idle time (default: 5 minutes)
timeouts.absolute_session_timeout = "30m"   # Maximum total session duration (default: 30 minutes)
timeouts.min_bytes_per_minute = 512         # Minimum throughput to prevent slowloris attacks (bytes/min, 0 = disabled, 512 recommended)

# --- SIEVE EXTENSIONS ---
# Supported SIEVE extensions advertised to clients and validated during script upload.
# MUST match (or be a subset of) what your backend ManageSieve servers support.
#
# This list determines which extensions clients can use in their SIEVE scripts.
# Extensions not in this list will be rejected during PUTSCRIPT with "extension not supported" error.
#
# Available extensions that go-sieve supports:
#   - fileinto, envelope, encoded-character, imap4flags, variables, relational, copy, regex, vacation
#   - comparator-i;octet, comparator-i;ascii-casemap, comparator-i;ascii-numeric, comparator-i;unicode-casemap
#
# Common production configuration (should match your backend):
supported_extensions = ["fileinto", "vacation", "envelope", "imap4flags", "variables", "relational", "copy", "regex"]

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# LMTP PROXY EXAMPLE
# =============================================================================
# Proxy LMTP connections across multiple backend servers for load balancing

[[server]]
type = "lmtp_proxy"
name = "lmtp-proxy-1"
addr = ":124"                 # Proxy listen address. Must be different from backend LMTP port.
remote_addrs = ["backend1.example.com:24", "backend2.example.com:24"]
max_connections = 1000
max_connections_per_ip = 0            # Typically no per-IP limits for LMTP (trusted sources)
# Note: max_connections_per_user not applicable for LMTP (no user authentication)

# --- PROXY TLS CONFIGURATION ---
tls = false
tls_use_starttls = false              # Use STARTTLS on listening port (client connections)
tls_cert_file = ""
tls_key_file = ""
tls_verify = true
# tls_default_domain = "lmtp.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this proxy.

# --- BACKEND TLS CONFIGURATION ---
remote_tls = false                    # Enable TLS for backend connections (implicit TLS or StartTLS)
remote_tls_use_starttls = false       # Use STARTTLS for backend connections (requires remote_tls = true)
remote_tls_verify = true              # Verify backend server TLS certificates
remote_use_proxy_protocol = true      # Send PROXY protocol headers to backends
remote_use_xclient = false            # Send XCLIENT command to backends for forwarding client info

# --- PROXY BEHAVIOR CONFIGURATION ---
connect_timeout = "30s"
auth_idle_timeout = "2m"
max_message_size = "50mb"
enable_affinity = true        # Enable user-to-backend affinity (requires [cluster.affinity] to be enabled)

# --- DEBUG LOGGING ---
debug = false                         # Enable debug logging (logs backend greetings/responses)


# METRICS SERVER EXAMPLE
# =============================================================================
# Prometheus metrics endpoint for monitoring Sora performance

[[server]]
type = "metrics"
name = "prometheus-metrics"
addr = ":9090"
path = "/metrics"             # HTTP endpoint path for metrics.
enable_domain_metrics = true
enable_user_metrics = false  # CAUTION: high cardinality, for small deployments only.
user_metrics_threshold = 1000
max_tracked_users = 1000
hash_usernames = true


# HTTP ADMIN API SERVER EXAMPLE
# =============================================================================
# REST API server for administrative operations (accounts, health, connections, etc.)
# Base URL: /admin/*

[[server]]
type = "http_admin_api"
name = "admin-api"
addr = ":8080"
api_key = "your-secret-api-key-here"  # REQUIRED for API access.
allowed_hosts = []            # Empty = all hosts (not recommended for production).
tls = false
tls_cert_file = ""            # Static cert file (or use Let's Encrypt autocert from [tls] section)
tls_key_file = ""             # Static key file (or use Let's Encrypt autocert from [tls] section)
tls_default_domain = ""       # [OPTIONAL] Default domain for SNI-less connections (uses global default_domain if not set)
tls_verify = false
proxy_protocol = false        # Enable PROXY protocol support for HTTP API
proxy_protocol_timeout = "5s"

# NOTE: Uses global [relay] configuration for /admin/mail/deliver endpoint
# NOTE: When tls=true and tls_cert_file/tls_key_file are empty, uses Let's Encrypt autocert from [tls] section


# HTTP USER API SERVER EXAMPLE
# =============================================================================
# REST API server for user mailbox access via HTTP (alternative to IMAP/POP3)
# Provides stateless JWT-based authentication for web and mobile clients
# Base URL: /user/*

[[server]]
type = "http_user_api"
name = "user-api"
addr = ":8081"
jwt_secret = "your-secret-jwt-signing-key-here"  # REQUIRED: Secret key for signing JWT tokens. KEEP SECRET!
token_duration = "24h"        # JWT token validity duration (e.g., "24h", "7d", "12h").
token_issuer = "sora-mail-api" # JWT issuer field (optional, for token validation).
allowed_origins = ["*"]       # CORS allowed origins for web clients. Use specific origins in production: ["https://mail.example.com"]
allowed_hosts = []            # IP addresses allowed to access API. Empty = all hosts.
tls = false
tls_cert_file = ""            # Static cert file (or use Let's Encrypt autocert from [tls] section)
tls_key_file = ""             # Static key file (or use Let's Encrypt autocert from [tls] section)
tls_default_domain = ""       # [OPTIONAL] Default domain for SNI-less connections (uses global default_domain if not set)
tls_verify = false

# NOTE: When tls=true and tls_cert_file/tls_key_file are empty, uses Let's Encrypt autocert from [tls] section


# USER API PROXY SERVER EXAMPLE
# =============================================================================
# HTTP reverse proxy for User API - routes requests to backend User API servers
# Authenticates JWT tokens on the proxy and forwards trusted requests to backends
# Supports user-based routing with consistent hashing for affinity
# Use for horizontal scaling of User API across multiple backend servers

#[[server]]
#type = "user_api_proxy"
#name = "user-api-proxy"
#addr = ":8082"                      # Frontend proxy listening address
#remote_addrs = ["backend1:8081", "backend2:8081", "backend3:8081"]  # Backend User API servers
#remote_port = 8081                  # Default backend port if not specified in remote_addrs
#jwt_secret = "your-secret-jwt-signing-key-here"  # REQUIRED: Same JWT secret as backend servers
#max_connections = 10000             # Maximum total concurrent connections (0 = unlimited)
#max_connections_per_ip = 100        # Maximum connections per client IP (0 = unlimited)
#connect_timeout = "10s"             # Timeout for establishing backend connections
#enable_affinity = true              # Enable user-to-backend affinity (sticky routing via consistent hashing)
#tls = false                         # Enable TLS on frontend proxy listener
#tls_cert_file = ""
#tls_key_file = ""
#tls_verify = false
#tls_default_domain = "api.example.com"   # [OPTIONAL] Override global default_domain for SNI-less connections on this proxy.
#remote_tls = false                  # Use HTTPS for backend connections
#remote_tls_verify = true            # Verify backend TLS certificates

# IMPORTANT: Backend User API servers should configure allowed_hosts to trust this proxy
# Backend configuration example:
# [[server]]
# type = "http_user_api"
# allowed_hosts = ["10.0.0.0/8"]  # Trust requests from proxy network
